<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DreamEcho - Oyente</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 2.5em; }
   button {
  margin: 0.5em 0.5em 0 0;
  font-size: 2em;         /* TamaÃ±o del texto y emoji */
  padding: 1em 2em;       /* MÃ¡s espacio interno */
}

    #status { margin-bottom: 1em; }
    #midiSelectContainer { margin-top: 1em; }
  </style>
</head>
<body>
  <h1>DreamEcho - Oyente</h1>
  <p id="status">Esperando conexiÃ³nâ€¦</p>

  <button onclick="modoMIDI()">ðŸŽ¹ Usar mi piano digital</button>
  <button onclick="modoVirtual()">ðŸŽ§ Escuchar con sonido virtual</button>

  <!-- Contenedor para el selector de dispositivos MIDI -->
  <div id="midiSelectContainer"></div>

  <script>
    const statusEl = document.getElementById("status");
    const midiSelectContainer = document.getElementById("midiSelectContainer");

    const ws = new WebSocket("wss://dreamecho.onrender.com");
    let output       = null;
    let modo         = null;
    let synth        = null;
    let pedal        = false;
    let baseTime     = null;
    let queuePos     = 0;
    let queueLatency = 100;   // latencia extra inicial para modo virtual
    const notasActivas    = new Set();
    const notasSostenidas = new Set();

    ws.onopen = () => {
      console.log("WebSocket conectado.");
      statusEl.textContent = "Conectado al servidor, esperando tu elecciÃ³nâ€¦";
    };

    ws.onmessage = async (event) => {
      const text = typeof event.data === 'string'
        ? event.data
        : await event.data.text();
      const message = JSON.parse(text);

      // 1ï¸âƒ£ Si es mensaje de stats: posiciÃ³n en cola
      if (message.type === "stats") {
        queuePos     = message.clients;
        queueLatency = 50 + 5 * Math.sqrt(queuePos);
        statusEl.textContent =
          `PosiciÃ³n en cola: ${queuePos} â†’ latencia = ${Math.round(queueLatency)} ms`;
        return;
      }

      // 2ï¸âƒ£ Si es mensaje MIDI
      if (message.type === "midi") {
        const [status, note, velocity] = message.data;
        const command   = status & 0xf0;
        const eventTime = message.time;

        // inicializar baseTime
        if (!baseTime) baseTime = performance.now() - eventTime;

        // calculamos el delay: timestamp + buffer de cola solo en virtual
        const extra = (modo === 'virtual') ? queueLatency : 0;
        const delay = Math.max(
          0,
          eventTime + baseTime - performance.now() + extra
        );
        const toneTime = "+" + (delay / 1000);

        // â”€â”€ Modo MIDI real â”€â”€
        if (modo === "midi" && output) {
          return setTimeout(() =>
            output.send(new Uint8Array(message.data)), delay
          );
        }

        // â”€â”€ Modo virtual â”€â”€
        if (modo === "virtual" && synth) {
          const freq = Tone.Frequency(note, "midi").toFrequency();

          if (command === 0x90 && velocity > 0) {
            if (!notasActivas.has(freq)) {
              Tone.Draw.schedule(() => {
                synth.triggerAttack(freq, undefined, velocity / 127);
              }, toneTime);
            }
            notasActivas.add(freq);
            notasSostenidas.delete(freq);

          } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
            if (pedal) {
              notasActivas.delete(freq);
              notasSostenidas.add(freq);
            } else {
              Tone.Draw.schedule(() => {
                synth.triggerRelease(freq, "+0.2");
              }, toneTime);
              notasActivas.delete(freq);
              notasSostenidas.delete(freq);
            }

          } else if (status === 176 && note === 64) {
            if (velocity >= 64) {
              pedal = true;
            } else {
              pedal = false;
              Tone.Draw.schedule(() => {
                for (let f of [...notasSostenidas]) {
                  if (!notasActivas.has(f)) {
                    synth.triggerRelease(f, "+0.2");
                    notasSostenidas.delete(f);
                  }
                }
              }, toneTime);
            }
          }
        }
      }
    };

    // â”€â”€ FunciÃ³n modo MIDI, con selector de dispositivo
    function modoMIDI() {
      modo = "midi";
      statusEl.innerText = "Buscando dispositivos MIDI de salidaâ€¦";

      navigator.requestMIDIAccess().then((midiAccess) => {
        const outputs = Array.from(midiAccess.outputs.values());
        if (outputs.length > 0) {
          // Crear selector
          midiSelectContainer.innerHTML = ""; 
          const select = document.createElement("select");
          select.id = "midiOutSelect";
          const defaultOption = document.createElement("option");
          defaultOption.text = "-- Elige dispositivo MIDI --";
          defaultOption.value = "";
          select.appendChild(defaultOption);

          outputs.forEach((out, idx) => {
            const option = document.createElement("option");
            option.value = out.id;
            option.text = out.name || `MIDI Dispositivo ${idx+1}`;
            select.appendChild(option);
          });

          // Al cambiar selecciÃ³n, asignar output
          select.addEventListener("change", (e) => {
            const chosenId = e.target.value;
            const chosen = outputs.find(o => o.id === chosenId);
            if (chosen) {
              output = chosen;
              statusEl.innerText = `Salida MIDI seleccionada: ${chosen.name}`;
            } else {
              statusEl.innerText = "No se ha seleccionado salida MIDI.";
              output = null;
            }
          });

          midiSelectContainer.appendChild(select);
          statusEl.innerText = "Selecciona un dispositivo MIDI para usarlo.";
        } else {
          statusEl.innerText = "No se han encontrado salidas MIDI.";
        }
      }).catch(() => {
        statusEl.innerText = "No se ha podido acceder a WebMIDI.";
      });
    }

    // â”€â”€ FunciÃ³n modo Virtual â”€â”€
    async function modoVirtual() {
      modo = "virtual";
      statusEl.innerText = "Cargando piano virtualâ€¦";
      await Tone.start();
      synth = new Tone.Sampler({
        urls: {
          A0:  "A0.mp3",  C1:  "C1.mp3",  "D#1":"Ds1.mp3", "F#1":"Fs1.mp3",
          A1:  "A1.mp3",  C2:  "C2.mp3",  "D#2":"Ds2.mp3", "F#2":"Fs2.mp3",
          A2:  "A2.mp3",  C3:  "C3.mp3",  "D#3":"Ds3.mp3", "F#3":"Fs3.mp3",
          A3:  "A3.mp3",  C4:  "C4.mp3",  "D#4":"Ds4.mp3", "F#4":"Fs4.mp3",
          A4:  "A4.mp3",  C5:  "C5.mp3",  "D#5":"Ds5.mp3", "F#5":"Fs5.mp3",
          A5:  "A5.mp3",  C6:  "C6.mp3",  "D#6":"Ds6.mp3", "F#6":"Fs6.mp3",
          A6:  "A6.mp3",  C7:  "C7.mp3",  "D#7":"Ds7.mp3", "F#7":"Fs7.mp3",
          A7:  "A7.mp3",  C8:  "C8.mp3"
        },
        baseUrl: "https://tonejs.github.io/audio/salamander/",
        release: 0.4,
        onload: () => {
          statusEl.innerText =
            `Modo virtual listo. PosiciÃ³n en cola: ${queuePos} (latencia â‰ƒ ${Math.round(queueLatency)} ms)`;
        }
      }).toDestination();
    }
  </script>
</body>
</html>
